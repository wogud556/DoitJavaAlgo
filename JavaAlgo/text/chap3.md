### 앞부분은 편하게 보고 이제부터 제대로할것
<br/>

## 3. 검색
---
### 검색과 키
- 어떤 검색을 하게 되면, 특정 항목에 주목하는 부분은 키라고 한다.
- 예를 들어 국적 검색 시 국적이 키이고, 나이 검색 시 나이가 키이다.
- 데이터가 단순한 정숫값이면 데이터 값을 키 값이라고 생각하면 좋지만, 대부분의 경우에서 키는 데이터의 일부일 뿐

### 배열에서 검색하기
1. 선형검색 : 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터모임에서 아주 빠른 검색을 수행
3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
    - 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
    - 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법
- 데이터 집합이 있을 때 단순 검색만 하면된다고 생각하면, 검색에 사용할 알고리즘은 게산시간이 짧은 것을 선택하면 된다.
- 그러나 데이터 집합에 대한 검색 뿐 아니라 데이터의 추가 삭제 등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여 알고리즘을 선택해야 한다.
    -  예를 들어 데이터 추가를 자주 하는 경우에는 검색이 빠르더라도 데이터의 추가비용이 많이 들어가는 알고리즘은 피해야 한다.
- 따라서 어떤 목적을 이루기 위해 선택할 수 있는 알고리즘이 여러가지인 경우 용도나 목적, 실행속도, 자료구조 등을 고려하여 알고리즘을 선택해야 한다.

### 3-2 선형 검색
- 요소가 직선모양으로 늘어선 배열에서 검색은 원하는 키 값을 갖는 요소를 만날 때 까지 앞부터 순서대로 요소를 검색하면 되는데 이것이 선형 검색 또는 순차 검색 이라는 알고리즘

### 실습 3-1(실습 파일 참조)
- 메서드 SeqSearch는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 key인 요소를 선형검색하고 검색한 요소의 인덱스를 반환
- 또한 값이 key인 요소가 여러개 존재할 경우 반환값은 검색 과정에서 처음 발견한 요소의 인덱스가 됨
- 값이 key인 요소가 존재하지 않으면 -1을 반환

### 실습 3-2
---
### 보초법
- 기존 선형검색은 반복할떄마다 다음의 종료조건을 모두 판단한다.
    - 종료 조건1) 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
    - 종료 조건2) 검색할 값과 같은 요소를 발견한 경우
- 보초법은 이 비용을 반으로 줄인다.(그림 책 참조)
- 방법
    - 먼저 초기 데이터를 준비한다.
    - 검색하고자 하는 데이터를 보초로 다음 인덱스를 생성하여 저장
    - 그럼 원하는 값이 원래 데이터에 존재하지 않아도 보초인 a[7]까지 검색하면 종료조건 2가 성립되기 떄무에 원하는 키값을 찾지 못했을 때를 판단하는 종료조건 1이 없어도 된다.
- 보초는 반복문에서 종료 판단횟수를 2회에서 1회로 줄이는 역할을 한다


### 실습 3-3
1. 검색할 값 key를 보초로 a[n]에 대입한다.
2. 배열 요소를 순서대로 검사한다. 앞서 실습 3-1의 while문에는 다음과 같은 if문이 2개 있었다.
```
if(i==n)
if(a[i]==key)
```
- 이 프로그램은 종료조건 1이 필요하지 않기 떄문에 하나의 if문만 사용. 따라서 반복종료에 대한 판단 횟수는 실제로 절반으로 줄어듬
3. while문에 의한 반복이 완료되면 찾은 값이 배열의 원래 데이터인지 아니면 보초인지 판단해야 한다. 변수 i값이 n이면 찾은 값이 보초이므로 검색 실패임을 나타내는 -1을 반환한다.

<br/>

## 이진 검색
---
- 이 알고리즘을 적용하는 전제조건은 데이터가 키 값으로 sort가 되었다는 전제로 진행한다.
- 이진검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.
- 알고리즘 순서
  - 먼저 중앙에 위치한 요소를 검색한다.
  - 검색하려는 값이 중앙에위치한 요소보다 크거나 작다면 앞쪽 혹은 뒷쪽으로 좁혀서 다음 검색 범위의 중앙에 위치한 값인지 확인한다.
  - 반복하여 결과를 도출한다.
- 이진 탐색 알고리즘의 종료 조건
  - a[pc]와 key가 일치하는 경우
  - 검색 범위가 더이상 없는 경우
### 실습 3-4

### 복잡도
- 프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
- 알고리즘의 성능을 객관저긍로 평가하는 기준을 복잡도라고 한다.
- 복잡도는 아래 두가지 요소를 가지고 있다
  - 시간복잡도 : 실행에 필요한 시간을 평가한 것
  - 공간복잡도 : 기억 영역과 파일 공간이 얼마나 필요한가를 평가

### 선형 검색의시간 복잡도
```
static int seqSearch(int[] a, int n, int key){
1    int i=0;
2    while(i <n){
3        if(a[i] == key)
4            return i; //검색 성공
5        i++;
     }
6    return -1;        //검색 실패
}
```
- 1은 병수를 대입하는 휫수는 처음 실행 이후 없다
- 이렇게 한번만 실행하는 경우 복잡도는 O(1)로 표기한다.
- 물론 메서드에서 값을 교환하는 4와 6도 한번 만 시행하기 때문에 O(1)로 표기한다.
- 배열의 맨 끝에 도달했는지를 판단하는 2와 현재 검사하고 있는 요소와 찾고자 하는 값이 같은지를 판단하는 3의 평균 실행 횟수는 /n/2이다.
- 이처럼 n에 비례하는 횟수만큼 실행하는 경우의 복잡도를 O(n) 으로 표기한다.

|단계|실행횟수|복잡도|
|---|------|---|
|1|1|O(1)|
|2|n/2|O(1)|
|3|n/2|O(1)|
|4|1|O(1)|
|5|n/2|O(1)|
|6|1|O(1)|

- 그런데 N이 점점 커지면, O(n)에 필요한 계산 시간은 n에 비례하여 점점 길어진다.
- 이와 달리 O(1)에 필요한 계산시간은 변하지 않는다.
- 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같다.
```
O(f(n)) + O(g(n)) = O(max(f(n), g(n))
```
- 2개 이상의 복잡도로 구성된 알고리즘의 전페 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시한다.
- 둘이 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지
- 다시 말해 전체 복잡도는 차원이 가장 높은 복잡도를 선택
- 그러므로 선형 검색 알고리즘의 복답도를 구하면 O(n)이 된다.

### 이진 검색의 시간 복잡도
- 이진 검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.
- 프로그램의 각 단계의 실행 횟수와 복잡도
```
static int binSearch(int[] a, int n, int key){
1  int pl = 0;
2  int pr = n -1;

  do{
3    int pc = (pl + pr) / 2;
4    if(a[pc] == key){
5      return pc;
6    else if(a[pc] < key)
7      pl = pc + 1;
    else
8      pr = pc - 1;

9  }while(pl <= pr>);

10  return -1;
}
```

|단계|실행횟수|복잡도|
|---|------|---|
|1|1|O(1)|
|2|1|O(1)|
|3|log n|O(log n)|
|4|log n|O(log n)|
|5|1|O(1)|
|6|log n|O(log n)|
|7|log n|O(log n)|
|8|log n|O(log n)|
|9|log n|O(log n)|
|10|1|O(1)|

- 고로 이진 검색 알고리즘의 복잡도를 구하면 아래처럼 O(log n)을 얻을 수 있다.

---
## Arrays.binarySearch에 의한 이진 검색
- Java는 배열에서 이진 검색을 하는 메서드를 표준 라이브러리로 제공
- 이진 검색 표준 라이브러리의 메서드로 java.util.Arrays클래스의 binarySearch 메서드가 있다.
- 이 메서드의 장점은
   1. 이진 검색 메서드를 직접 코딩할 필요가 없다
   2. 모든 자료형 배열에서 검색할 수 있다.
- binarySearch 메서드는 오름차순으로 정려로딘 배열 a를 가정하고, 키 값이 key인 요소를 이진 검색한다.
- BinarySearch 메서드는 자료형에 따라 9가지 방법으로 오버로딩 되어있다.

### 검색에 성공한 경우
- key와 일치하는 요소의 인덱스를 반환한다.
- 일치하는 요소가 여러개 있다면 무작위의 인덱스를 반환한다.
- 맨 앞의 인덱스나 어떤 특정한 인덱스를 반환하는 것이 아니다.

### 검색에 실패한 경우
- 반환값은 삽입 포인트를 x라고 할때 -x -1을 반환한다. 
- 삽입포인트는 검색하기 위해 지정한 key보다 큰 요소 중 첫번째 요소의 인덱스이다.
- 만약 배열의 모든 요소가 key보다 작다면 배열의 길이를 삽입 포인트로 정한다.

### 기본 자료형 배열에서 binarySearch 메서드로 검색하기
- binarySearch메서드는 int형이나 long 형과 같은 기본 자료형 배열에서 이진 검색을 하는 메서드이다.
- 실습 3-5참조

### 보충수업3-2(중요하다 판단이 되어)
- Java 메서드의 종류는 다음과 같이 두가지이다.
  1. 인스턴스 메서드(비정적 메서드)
  2. 클래스 메서드(정적 메서드)
- 간단히 말해 인스턴스 메서드는 static을 붙이지 않고 선언한 메서드이고, 클래스 메서드는 static을 붙여 선언한 메서드이다.
- 둘의 차이점은 메서드가 인스턴스에 포함되는지의 여부에 있다.
- 그래서 클래스 메서드는 클래스 전체에 대한 처리를 담당하며 인스턴스 메서드와 처리 영역을 구분하기 위해 주로 사용한다.
- 클래스 메서드와 마찬가지로 클래스 변수도 인스턴스에 포함되지 않는 변수이다.
- 또한 인스턴스 개수와 관계없이 1개만 만들어진다.
- 즉 클래스 변수를 통해 몇개의 아이디를 만들었는지 알 수 있으며 아이디로 사용할 수 있다.

### 객체의 배열에서 검색하기
- 객체의 배열에서도 검색할 수 있다.
- static int binarySearch(Object[] a, Object key)
  - 자연정렬이라는 방법으로 요소의 대소관계를 판단한다.
  - 따라서 정수배열, 문자열 배열에서 검색할 때 적당하다.
- static<T> int binarySearch(T[]a, T key, Comparator<? super T> c)
  - 자연순서가 아닌 순서로 줄지어 있는 배열에서 검색하거나 "자연순서"를 논리적으로 갖지 않는 클래스 배열에서 검색할 때 알맞다.


### 자연 정렬로 정렬된 배열에서 검색하기
- 다음은 자연 정렬에서 대소관계를 비교하는 메서드를 사용하여 검색하는 프로그램이다.
- 검색 대상인 x는 문자열 배열.
- 문자열 ky에 입력하고 배열 x와 키 값 ky를 binarySearch 메서드에 전달하면 검색할 수 있다.
- 실습 3-6 생략

### 자연정렬이란
- binarySearch 메서드에 배열과 키 값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스